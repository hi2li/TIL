# Section 1. 기본 설치 및 유형
## [리눅스의 설치준비]

### (1) 리눅스 설치의 개요

- <리눅스 배포판과 설치파일의 일반적인 특징>
    - 리눅스 설치파일은 해당 배포본의 홈페이지에서 다운로드 받을 수 있다.
    - 목적과 장치에 따라 많은 종류의 리눅스 운영체제가 존재한다.
- <설치 환경과 설치 유형>
    - 배포판마다 설치환경과 설치과정이 다름
    - 패키지에 따라 데스크톱형, 서버형, 사용자 정의형으로 구분한다.
        - Minimal : 리눅스 설치시 필수 패키지만 설치
        - 데스크톱 : 개인용 컴퓨터에 적합한 패키지를 설치 (문서 작성, 멀티미디어, 그래픽 도구 등등)
        - 서버 : 서버 운영에 적합한 패키지를 설치
        - 랩탑 : 노트북등 랩탑 시스템에 적합한 시스템 설치
        - 가상 호스트 : 가상화 시스템 운영을 위한 패키지 설치 (하이퍼바이저 KVM이나 Xen을 설치)
        - software development worksatation : 소프트웨어 설치 시 필요한 도구들이 포함된 패키지 설치
        - 사용자 설정 시스템 : 사용자 취향에 맞는 소프트웨어 선택 후 설치
    - 사용자 설정 시스템을 제외한 다른 설치 유형을 선택하게 되면 기존 데이터는 모두 제거된다.
- <리눅스 설치 전 준비와 주의사항>
    - 디스크를 티션 하면 그 디스크에 있는 모든 파일들이 지워지기 때문에 반드시 백업해둔다.
    - 멀티 부팅 시스템을 만들기 위해서는 현재 운영체제의 배포 미디어를 가지고 있어야한다. (파티션을 많이 건드리는 설정이기 떄문에 시스템 설정중 망가지면 다시 깔 수 있어야함)
    

### (2) 리눅스 설치를 위한 하드웨어 정보 파악

- <하드웨어 정보>
    - 하드웨어 정보를 파악해야 설치 작업이 용이하고 하드웨어 문제가 발생했을 때, 장애처리의 실마리가 될 수 있다.
    - 최근 리눅스 배포판들은 하드웨어의 호환성이 훌륭하다.
    - 설치 마법사의 plug and play(PNP)기능으로 자동으로 하드웨어를 찾아낸다. → 장치를 꽂기만 하면 바로 쓸 수 있게 해줌. 자동으로 자원할당과 드라이버 설치를 해줌.
    - 하드웨어 목록
        - CPU
        - 메모리 (RAM)
        - 하드디스크 드라이브
        - 네트워크 인터페이스
        - 모니터
        - 프린터
        - 키보드
        - 마우스
        - 비디오카드(그래픽카드)

- <하드웨어 호환성>
    - 리눅스는 많은 하드웨어 제품들에서 문제없이 작동하지만 다른 운영체제만큼은 아니다.
- <네트워크 설정>
    - 시스템 관리자는 네트워크 설정에 필요한 정보를 알고 있어야함
        - 호스트네임과 도메인
        - 컴퓨터의 IP주소, 서브넷 마스크
        - 게이트웨이 주소
        - DNS 서버 주소
    - 만약 무선 네트워크를 사용한다면 무선 네트워크 SSID와 보안키를 사용할 경우 WEP키를 확인 해야한다.

# Section 2. 파티션
## [파티션과 저장장치의 기본구조]

### (1) 파티션

- 하나의 물리적 디스크를 여러 개의 논리적 디스크로 분할하는 것이다.

<파티션의 장점>

- 파티션마다 독립적인 파일 시스템이 운영됨 → 파일점검시간 감소 → 부팅시간 감축
- 특정 파티션의 파일 시스템이 손상되어도 다른 파티션에 영향을 주지 않음
- 필요한 파티션만 독립적으로 포맷할 수 있음 → 백업과 업그레이드가 편함
- 파티션 상태 정보를 확인할 수 있는 파일은 “/proc/partitions”이다.

<파티션의 종류>

- 주 파티션
    - 부팅이 가능함
    - 하나의 하드디스크의 최대 4개의 주 파티션 분할이 가능하다
    - 하드디스크를 4개 이상으로 파티션할 때는 하나의 확장 파티션을 설정하여 확장 파티션 안에 여러 개의 논리 파티션을 분할한다.
- 확장 파티션
    - 주 파티션 내에 생성하며 하나의 물리적 디스크에 1개만 생성한다.
    - 파티션 번호는 주 파티션과 함께 1~4번 중 하나를 차지
        - 1,2,3번 주 파티션, 4번 확장 파티션, 5번부터 확장파티션 안에서..
    - 데이터 저장 영역을 위한 것이 아니라 논리 파티션을 생성하기 위해 존재.
- 논리 파티션
    - 확장 파티션 안에 생성되는 파티션
    - 논리 파티션은 12개 이상 생성하지 않는 것을 권고하며 4번 이후의 번호가 붙여짐.
- 스왑파티션 (스왑 메모리라고도 함)
    - 하드디스크의 일부를 메모리처럼 사용하는 영역
    - 주 파티션 또는 논리파티션에 생성
    - 프로그램 실행 시 부족한 메모리 용량을 하드디스크로 대신함
    - 리눅스 설치 시에 반드시 설치되어야  하는 영역
    - swqp 영역의 크기는 메모리의 2배를 설정하도록 권고

### (2) 디스크와 장치명

<특징>

- 분할된 파티션은 디스크의 장치 파일명 뒤에 숫잘르 붙인다.
- 리눅스에서 파티션을 만들고 마운트할 때 지정된 디바이스명을 사용해야한다.
- 장치명은 크게 세 부분으로 나뉜다
- 예 ) sda1
    - sd → 하드디스크유형. (ssd, usb는 sd, 하드디스크는 hd)
    - a → 하드디스크의 순서.(  첫 번째 하드디스크는 a, 두번쨰는 b)
    - 1 → 파티션 번호(한 디스크 내부의 파티션들에게 주어지는 번호)
 
## [파일 시스템과 논리적 저장공간 관리]

### (1) 파일 시스템

<파일 시스템의 개념과 특징>

- 파일 시스템은 디스크 파티션위에 파일과 폴더를 저장하고 관리하는 규칙과 구조이다.
- 일정한 규칙을 가지고 파일을 저장하도록 규칙칙 방식을 제시한다.
- 파티션에 파일 시스템이 없으면, 파일 시스템 생성을 거쳐야 사용이 가능하다.

<리눅스의 파일 시스템>

- 리눅스 : ext, ext2, ext3, ext4
- 저널링 파일 시스템 : JFS, XFS, ReiserFS
- 네트워크 파일 시스템 : SMB, CIFS, NFS
- 클러스터링 파일 시스템 : 래드햇 GFS, IBM GPFS등등

### (2) LVM(Logical Volume Manager)

<LVM의 특징>

- 리눅스에서 디스크를 유연하게 관리하는 기술이다. 파티션의 단점(고정크기, 이동이 어려움)등을 해결할 수 있음.  (크기 조정에 초점)
- 쉽게 말하면 나눠져있는 것을 하나로 다 합쳐버린다음에 원하는 만큼 떼어서 사용하는 것
- 여러 개의 하드디스크를 합쳐서 사용하는 기술로 한 개의 파일 시스템을 사용한다.
- 작은 용량의 하드디스크 여러 개를 큰 용량의 하드디스크를 한 개처럼 사용한다.
- 서버를 운영하면서 대용량의 별도 저장 공간이 필요할 때 활용한다.
- 다수의 디스크를 묶어서 사용함으로써 파티션의 크기를 줄이거나 늘릴 수 있다.

- ## [고급 디스크 구성과 파티션 관리]

### (1) RAID (Redundant Array of independent Disks) → 독립 디스크의 복수배열

<RAID의 개념과 특징>

- 여러 개의 물리적 디스크를 조합하여 논리 디스크로 만들고 안정성 혹은 성능을 향상시키는 기술

<RAID의 종류>

- 하드웨어 RAID
    - 하드웨어 제조업체에서 여러 개의 하드디스크를 장비로 만들어 그 자체를 공급
    - 안정된 시스템일수록 고가
- 소프트웨어 RAID
    - 고가의 하드웨어 RAID의 대안적 방식
    - 운영체제에서 지원하는 방식
    - 저렴하게 안전한 데이터 저장이 가능

<RAID와 레벨>

- 데이털르 저장하는 다양한 방법이 존재하며 이 방법들을 레벨로 구분한다.
- 레벨에 따라 저장장치의 신뢰성을 높이거나 전체적인 성능을 향상시키는 등 다양한 목적을 만족시킨다.
    - RAID 0 - 스트라이핑(연속된 데이터를 여러 디스크의 나눠서 저장)
        - 최소 2개의 하드디스크가 필요
        - 입출력 작업이 두 개 디스크에서 병행해서 진행되기 때문에 속도가 빨라진다
        - 하나의 디스크라도 고장나면 전체 시스템 사용불가
    - RAID 1 - 미러링 (하나의 디스크에 데이터를 저장하면 다른 디스크에 동일한 내용이 백업되어 저장)
        - 데이터 저장 시 두 배의 용량이 필요
        - 백업된다는 측면에서 안정성이 높다고 볼 수 있음
    - RAID 2 - 비트 단위 스트라이핑 + 해밍코드
        - 데이터를 비트 단위로 잘게 쪼개서 여러 디스크에 나눠서 저장
        - 최소 3개 이상의 하드디스크 필요
        - 해밍 코드를 저장하는 전용 디스크들이 필요함
        - 디스크 1개가 고장나도 복구가 가능하다
        - 현재는 쓰지 않음(현대 디스크는 자체 오류 검출 기능이 있음)
    - RAID 3 - 바이트 단위 스트라이핑 + 패리티 1개
        - 최소 디스크수 3개(데이터2, 패리티1)
        - 데이터를 바이트 단위로 나눠서 저장
        - 패리티 정보는 전용 디스크 1개의 저장
        - 디스크 1개 고장 시 복구 가능
        - 패리티 디스크 병목 문제 존재 (모든 패리티가 하나의 패리티 디스크에만 저장됨. → 부하집중)
    - RAID 4- 블록 단위 스트라이핑 + 패리티 1개
        - 최소 디스크 수 3개 (데이터2, 패리티1)
        - 데이터를 블록단위로 나눠서 저장
        - 패리티를 전용 디스크 1개로 저장
        - 디스크 1개 고장 시 복구 가능
        - 패리티 디스크 병목 문제 존재 (모든 패리티가 하나의 패리티 디스크에만 저장됨. → 부하집중)
    - RAID 5 - 블록 단위 스트라이팅 + 분산 패리티
        - 최소 디스크 수 3개
        - 데이터를 블록 단위로 여러 디스크에 나눠서 저장
        - 패리티를 모든 디스크에 분산하여 저장한다. → 병목 문제 해결
        - 다만 쓰기 시 패리티 계산이 들어가기 때문에 오버헤드 존재
        - 디스크가 1개 고장날 때만 복구가 가능
        - 성능, 용량, 안정성의 균형이 좋아서 가장 널리 사용됨
    - RAID 6 - 블록 단위 스트라이핑 + 이중 분산 패리티
        - 최소 디스크 수 4개
        - 데이터를 블록 단위로 나눠서 저장
        - 패리티를 2개 생성하여 모든 디스크에 분산 저장
        - 디스크가 2개 고장까지 복구 가능
        - 쓰기 성능은 RAID5 보다 느림.
    - RAID 0 + 1
        - 먼저 스트라이핑 (raid0)으로 묶고
        - 그 스트라이핑 묶음을 통째로 복제
        - 스트라이핑 후 미러링
    - RAID 1 + 0
        - 먼저 디스크 2개씩 미러링
        - 그 미러 세트들을 스트라이핑으로 묶음.
        - 미러링 후 스트라이핑

<레벨에 따른 디스크 사용량>

| RAID | 사용 가능 용량 공식 |
| --- | --- |
| RAID 0 | `N × S` |
| RAID 1 | `(N ÷ 2) × S` |
| RAID 5 | `(N − 1) × S` |
| RAID 6 | `(N − 2) × S` |

### (2) 파티션 분할

<fdisk의 개념과 기능>

- 파티션 테이블을 관리하는 명령어
- 디스크 파티션을 생성, 수정,삭제할 수 있는 유틸리티

<fdisk 명령어>

- a : 부팅 파티션 지정
- l : 파티션 종류 선택시 지원하는 파티션 목록 확인
- n : 새로운 파티션 추가
- t : 파티션 종류 변경
- w : 파티션 정보 저장
- p : 파티션 정보 확인
- q :  작업 종료
- 

# Section 3. 부트 매니저

## [부팅 과정의 이해]

### (1) 리눅스의 부팅

<부팅의 개념>

- 부팅은 PC의 전원을 켜는 순간부터 리눅스의 완전히 동작하여 로그인 프롬프트가 출력될 떄까지를 의미
- 리눅스 부팅 과정은 PC 부팅과 리눅스 부팅으로 나뉜다.

<리눅스 부팅 전체 과정>

- 전원 버튼을 누르면 가장 먼저 BIOS가 실행된다.
- BIOS는 하드웨어가 정상적인지 검사하고 설정된 부팅 순서에 따라 부팅할 디스크를 선택한다.
- 그 후에 BIOS가 선택한 디스크에 있는 MBR을 메모리로 읽어온다.  (첫 512바이트를 적재)
    - MBR : 디스크의 가장 첫 영역으로 파티션 정보와 부트로더 실행하는 코드를 담고있음
- MBR안에 있는 코드를 실행하면 부트로더가 실행된다. (리눅스에서는 보통 GRUB)
    - 정확히는 MBR안의 부트코드가 GRUB의 1단계를 실행
- GRUB는 사용자에게 부팅할 운영체제나 커널을 선택할 기회를 줌
- 선택이 끄나면 리눅스 커널을 메모리에 적재한디 필요한 부팅 옵션과 함께 커널에 제어권을 넘김
- 이제 커널이 실행되면서 리눅스가 본격적으로 동작한다.
- 커널은 메모리 관리, 프로세스 관리, 장치 드라이버 초기화 같은 핵심 작업을 수행하고, 루트 파일 시스템을 마운트 한 후 최초의 사용자 공간 프로세스를 실행한다.
- 이게 바로 Systemd이다. systemd는 PID 가 1인 프로세스이며 시스템 전체의 서비와 데몬을 관리한다.
- systemd는 네트워크, 로그, 각종 시스템 서비스를 순서대로 실행해 시스템을 사용한 가능한 상태로 만들고 나서 그 후 로그인 서비스를 제공한다.
- 마지막으로 사요아가 아이디와 비밀번호를 입력해 로그인하면 bash등의 로그인 쉘이 실행되고, 이 시점부터 사용자는 리눅스를 직접 사용하게 된다.

### **① BIOS**

- 전원 ON 시 **가장 먼저 실행**
- 하드웨어 점검(POST)
- 부팅 장치 선택

**이후 디스크의 부트 영역을 읽도록 지시**

---

### **② MBR (Master Boot Record)**

- 디스크 **첫 번째 섹터**

- 파티션 정보 + 부트 코드 포함
- **Boot Loader 실행**

**이후 GRUB 로드**

---

### **③ Boot Loader (GRUB)**

- 부팅할 OS 선택 (부팅 가능한 OS목록이 표시됨)
- **리눅스 커널을 메모리에 적재**
- 커널에 부팅 옵션 전달
- 커널에게 제어권을 넘김

**이후 Kernel 커널이 실행됨**

---

### **④ Kernel**

- 리눅스 핵심
- 메모리, 프로세스, 디바이스 관리
- 루트 파일 시스템 마운트

**이후 최초 프로세스(systemd) 실행**

---

### **⑤ systemd (PID 1)**

- 커널이 실행하는 **첫 프로세스**
- PID = 1
- 각종 서비스/데몬 실행 (네트워크 서비스, 로기시스템 등등)
- 멀티유저 환경 구성
- 부팅 단계 관리

**이후 로그인 환경 준비**

---

### **⑥ Login Shell**

- 사용자 로그인
- 쉘 실행 (`bash` 등)
- 시스템 사용 가능 상태
