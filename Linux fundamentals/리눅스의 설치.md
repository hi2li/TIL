# Section 1. 기본 설치 및 유형
## [리눅스의 설치준비]

### (1) 리눅스 설치의 개요

- <리눅스 배포판과 설치파일의 일반적인 특징>
    - 리눅스 설치파일은 해당 배포본의 홈페이지에서 다운로드 받을 수 있다.
    - 목적과 장치에 따라 많은 종류의 리눅스 운영체제가 존재한다.
- <설치 환경과 설치 유형>
    - 배포판마다 설치환경과 설치과정이 다름
    - 패키지에 따라 데스크톱형, 서버형, 사용자 정의형으로 구분한다.
        - Minimal : 리눅스 설치시 필수 패키지만 설치
        - 데스크톱 : 개인용 컴퓨터에 적합한 패키지를 설치 (문서 작성, 멀티미디어, 그래픽 도구 등등)
        - 서버 : 서버 운영에 적합한 패키지를 설치
        - 랩탑 : 노트북등 랩탑 시스템에 적합한 시스템 설치
        - 가상 호스트 : 가상화 시스템 운영을 위한 패키지 설치 (하이퍼바이저 KVM이나 Xen을 설치)
        - software development worksatation : 소프트웨어 설치 시 필요한 도구들이 포함된 패키지 설치
        - 사용자 설정 시스템 : 사용자 취향에 맞는 소프트웨어 선택 후 설치
    - 사용자 설정 시스템을 제외한 다른 설치 유형을 선택하게 되면 기존 데이터는 모두 제거된다.
- <리눅스 설치 전 준비와 주의사항>
    - 디스크를 티션 하면 그 디스크에 있는 모든 파일들이 지워지기 때문에 반드시 백업해둔다.
    - 멀티 부팅 시스템을 만들기 위해서는 현재 운영체제의 배포 미디어를 가지고 있어야한다. (파티션을 많이 건드리는 설정이기 떄문에 시스템 설정중 망가지면 다시 깔 수 있어야함)
    

### (2) 리눅스 설치를 위한 하드웨어 정보 파악

- <하드웨어 정보>
    - 하드웨어 정보를 파악해야 설치 작업이 용이하고 하드웨어 문제가 발생했을 때, 장애처리의 실마리가 될 수 있다.
    - 최근 리눅스 배포판들은 하드웨어의 호환성이 훌륭하다.
    - 설치 마법사의 plug and play(PNP)기능으로 자동으로 하드웨어를 찾아낸다. → 장치를 꽂기만 하면 바로 쓸 수 있게 해줌. 자동으로 자원할당과 드라이버 설치를 해줌.
    - 하드웨어 목록
        - CPU
        - 메모리 (RAM)
        - 하드디스크 드라이브
        - 네트워크 인터페이스
        - 모니터
        - 프린터
        - 키보드
        - 마우스
        - 비디오카드(그래픽카드)

- <하드웨어 호환성>
    - 리눅스는 많은 하드웨어 제품들에서 문제없이 작동하지만 다른 운영체제만큼은 아니다.
- <네트워크 설정>
    - 시스템 관리자는 네트워크 설정에 필요한 정보를 알고 있어야함
        - 호스트네임과 도메인
        - 컴퓨터의 IP주소, 서브넷 마스크
        - 게이트웨이 주소
        - DNS 서버 주소
    - 만약 무선 네트워크를 사용한다면 무선 네트워크 SSID와 보안키를 사용할 경우 WEP키를 확인 해야한다.

# Section 2. 파티션
## [파티션과 저장장치의 기본구조]

### (1) 파티션

- 하나의 물리적 디스크를 여러 개의 논리적 디스크로 분할하는 것이다.

<파티션의 장점>

- 파티션마다 독립적인 파일 시스템이 운영됨 → 파일점검시간 감소 → 부팅시간 감축
- 특정 파티션의 파일 시스템이 손상되어도 다른 파티션에 영향을 주지 않음
- 필요한 파티션만 독립적으로 포맷할 수 있음 → 백업과 업그레이드가 편함
- 파티션 상태 정보를 확인할 수 있는 파일은 “/proc/partitions”이다.

<파티션의 종류>

- 주 파티션
    - 부팅이 가능함
    - 하나의 하드디스크의 최대 4개의 주 파티션 분할이 가능하다
    - 하드디스크를 4개 이상으로 파티션할 때는 하나의 확장 파티션을 설정하여 확장 파티션 안에 여러 개의 논리 파티션을 분할한다.
- 확장 파티션
    - 주 파티션 내에 생성하며 하나의 물리적 디스크에 1개만 생성한다.
    - 파티션 번호는 주 파티션과 함께 1~4번 중 하나를 차지
        - 1,2,3번 주 파티션, 4번 확장 파티션, 5번부터 확장파티션 안에서..
    - 데이터 저장 영역을 위한 것이 아니라 논리 파티션을 생성하기 위해 존재.
- 논리 파티션
    - 확장 파티션 안에 생성되는 파티션
    - 논리 파티션은 12개 이상 생성하지 않는 것을 권고하며 4번 이후의 번호가 붙여짐.
- 스왑파티션 (스왑 메모리라고도 함)
    - 하드디스크의 일부를 메모리처럼 사용하는 영역
    - 주 파티션 또는 논리파티션에 생성
    - 프로그램 실행 시 부족한 메모리 용량을 하드디스크로 대신함
    - 리눅스 설치 시에 반드시 설치되어야  하는 영역
    - swqp 영역의 크기는 메모리의 2배를 설정하도록 권고

### (2) 디스크와 장치명

<특징>

- 분할된 파티션은 디스크의 장치 파일명 뒤에 숫잘르 붙인다.
- 리눅스에서 파티션을 만들고 마운트할 때 지정된 디바이스명을 사용해야한다.
- 장치명은 크게 세 부분으로 나뉜다
- 예 ) sda1
    - sd → 하드디스크유형. (ssd, usb는 sd, 하드디스크는 hd)
    - a → 하드디스크의 순서.(  첫 번째 하드디스크는 a, 두번쨰는 b)
    - 1 → 파티션 번호(한 디스크 내부의 파티션들에게 주어지는 번호)
 
## [파일 시스템과 논리적 저장공간 관리]

### (1) 파일 시스템

<파일 시스템의 개념과 특징>

- 파일 시스템은 디스크 파티션위에 파일과 폴더를 저장하고 관리하는 규칙과 구조이다.
- 일정한 규칙을 가지고 파일을 저장하도록 규칙칙 방식을 제시한다.
- 파티션에 파일 시스템이 없으면, 파일 시스템 생성을 거쳐야 사용이 가능하다.

<리눅스의 파일 시스템>

- 리눅스 : ext, ext2, ext3, ext4
- 저널링 파일 시스템 : JFS, XFS, ReiserFS
- 네트워크 파일 시스템 : SMB, CIFS, NFS
- 클러스터링 파일 시스템 : 래드햇 GFS, IBM GPFS등등

### (2) LVM(Logical Volume Manager)

<LVM의 특징>

- 리눅스에서 디스크를 유연하게 관리하는 기술이다. 파티션의 단점(고정크기, 이동이 어려움)등을 해결할 수 있음.  (크기 조정에 초점)
- 쉽게 말하면 나눠져있는 것을 하나로 다 합쳐버린다음에 원하는 만큼 떼어서 사용하는 것
- 여러 개의 하드디스크를 합쳐서 사용하는 기술로 한 개의 파일 시스템을 사용한다.
- 작은 용량의 하드디스크 여러 개를 큰 용량의 하드디스크를 한 개처럼 사용한다.
- 서버를 운영하면서 대용량의 별도 저장 공간이 필요할 때 활용한다.
- 다수의 디스크를 묶어서 사용함으로써 파티션의 크기를 줄이거나 늘릴 수 있다.

- ## [고급 디스크 구성과 파티션 관리]

### (1) RAID (Redundant Array of independent Disks) → 독립 디스크의 복수배열

<RAID의 개념과 특징>

- 여러 개의 물리적 디스크를 조합하여 논리 디스크로 만들고 안정성 혹은 성능을 향상시키는 기술

<RAID의 종류>

- 하드웨어 RAID
    - 하드웨어 제조업체에서 여러 개의 하드디스크를 장비로 만들어 그 자체를 공급
    - 안정된 시스템일수록 고가
- 소프트웨어 RAID
    - 고가의 하드웨어 RAID의 대안적 방식
    - 운영체제에서 지원하는 방식
    - 저렴하게 안전한 데이터 저장이 가능

<RAID와 레벨>

- 데이털르 저장하는 다양한 방법이 존재하며 이 방법들을 레벨로 구분한다.
- 레벨에 따라 저장장치의 신뢰성을 높이거나 전체적인 성능을 향상시키는 등 다양한 목적을 만족시킨다.
    - RAID 0 - 스트라이핑(연속된 데이터를 여러 디스크의 나눠서 저장)
        - 최소 2개의 하드디스크가 필요
        - 입출력 작업이 두 개 디스크에서 병행해서 진행되기 때문에 속도가 빨라진다
        - 하나의 디스크라도 고장나면 전체 시스템 사용불가
    - RAID 1 - 미러링 (하나의 디스크에 데이터를 저장하면 다른 디스크에 동일한 내용이 백업되어 저장)
        - 데이터 저장 시 두 배의 용량이 필요
        - 백업된다는 측면에서 안정성이 높다고 볼 수 있음
    - RAID 2 - 비트 단위 스트라이핑 + 해밍코드
        - 데이터를 비트 단위로 잘게 쪼개서 여러 디스크에 나눠서 저장
        - 최소 3개 이상의 하드디스크 필요
        - 해밍 코드를 저장하는 전용 디스크들이 필요함
        - 디스크 1개가 고장나도 복구가 가능하다
        - 현재는 쓰지 않음(현대 디스크는 자체 오류 검출 기능이 있음)
    - RAID 3 - 바이트 단위 스트라이핑 + 패리티 1개
        - 최소 디스크수 3개(데이터2, 패리티1)
        - 데이터를 바이트 단위로 나눠서 저장
        - 패리티 정보는 전용 디스크 1개의 저장
        - 디스크 1개 고장 시 복구 가능
        - 패리티 디스크 병목 문제 존재 (모든 패리티가 하나의 패리티 디스크에만 저장됨. → 부하집중)
    - RAID 4- 블록 단위 스트라이핑 + 패리티 1개
        - 최소 디스크 수 3개 (데이터2, 패리티1)
        - 데이터를 블록단위로 나눠서 저장
        - 패리티를 전용 디스크 1개로 저장
        - 디스크 1개 고장 시 복구 가능
        - 패리티 디스크 병목 문제 존재 (모든 패리티가 하나의 패리티 디스크에만 저장됨. → 부하집중)
    - RAID 5 - 블록 단위 스트라이팅 + 분산 패리티
        - 최소 디스크 수 3개
        - 데이터를 블록 단위로 여러 디스크에 나눠서 저장
        - 패리티를 모든 디스크에 분산하여 저장한다. → 병목 문제 해결
        - 다만 쓰기 시 패리티 계산이 들어가기 때문에 오버헤드 존재
        - 디스크가 1개 고장날 때만 복구가 가능
        - 성능, 용량, 안정성의 균형이 좋아서 가장 널리 사용됨
    - RAID 6 - 블록 단위 스트라이핑 + 이중 분산 패리티
        - 최소 디스크 수 4개
        - 데이터를 블록 단위로 나눠서 저장
        - 패리티를 2개 생성하여 모든 디스크에 분산 저장
        - 디스크가 2개 고장까지 복구 가능
        - 쓰기 성능은 RAID5 보다 느림.
    - RAID 0 + 1
        - 먼저 스트라이핑 (raid0)으로 묶고
        - 그 스트라이핑 묶음을 통째로 복제
        - 스트라이핑 후 미러링
    - RAID 1 + 0
        - 먼저 디스크 2개씩 미러링
        - 그 미러 세트들을 스트라이핑으로 묶음.
        - 미러링 후 스트라이핑

<레벨에 따른 디스크 사용량>

| RAID | 사용 가능 용량 공식 |
| --- | --- |
| RAID 0 | `N × S` |
| RAID 1 | `(N ÷ 2) × S` |
| RAID 5 | `(N − 1) × S` |
| RAID 6 | `(N − 2) × S` |

### (2) 파티션 분할

<fdisk의 개념과 기능>

- 파티션 테이블을 관리하는 명령어
- 디스크 파티션을 생성, 수정,삭제할 수 있는 유틸리티

<fdisk 명령어>

- a : 부팅 파티션 지정
- l : 파티션 종류 선택시 지원하는 파티션 목록 확인
- n : 새로운 파티션 추가
- t : 파티션 종류 변경
- w : 파티션 정보 저장
- p : 파티션 정보 확인
- q :  작업 종료
- 

# Section 3. 부트 매니저

## [부팅 과정의 이해]

### (1) 리눅스의 부팅

<부팅의 개념>

- 부팅은 PC의 전원을 켜는 순간부터 리눅스의 완전히 동작하여 로그인 프롬프트가 출력될 떄까지를 의미
- 리눅스 부팅 과정은 PC 부팅과 리눅스 부팅으로 나뉜다.

<리눅스 부팅 전체 과정>

- 전원 버튼을 누르면 가장 먼저 BIOS가 실행된다.
- BIOS는 하드웨어가 정상적인지 검사하고 설정된 부팅 순서에 따라 부팅할 디스크를 선택한다.
- 그 후에 BIOS가 선택한 디스크에 있는 MBR을 메모리로 읽어온다.  (첫 512바이트를 적재)
    - MBR : 디스크의 가장 첫 영역으로 파티션 정보와 부트로더 실행하는 코드를 담고있음
- MBR안에 있는 코드를 실행하면 부트로더가 실행된다. (리눅스에서는 보통 GRUB)
    - 정확히는 MBR안의 부트코드가 GRUB의 1단계를 실행
- GRUB는 사용자에게 부팅할 운영체제나 커널을 선택할 기회를 줌
- 선택이 끄나면 리눅스 커널을 메모리에 적재한디 필요한 부팅 옵션과 함께 커널에 제어권을 넘김
- 이제 커널이 실행되면서 리눅스가 본격적으로 동작한다.
- 커널은 메모리 관리, 프로세스 관리, 장치 드라이버 초기화 같은 핵심 작업을 수행하고, 루트 파일 시스템을 마운트 한 후 최초의 사용자 공간 프로세스를 실행한다.
- 이게 바로 Systemd이다. systemd는 PID 가 1인 프로세스이며 시스템 전체의 서비와 데몬을 관리한다.
- systemd는 네트워크, 로그, 각종 시스템 서비스를 순서대로 실행해 시스템을 사용한 가능한 상태로 만들고 나서 그 후 로그인 서비스를 제공한다.
- 마지막으로 사요아가 아이디와 비밀번호를 입력해 로그인하면 bash등의 로그인 쉘이 실행되고, 이 시점부터 사용자는 리눅스를 직접 사용하게 된다.

- **BIOS**
    - 전원 ON 시 **가장 먼저 실행**
    - 하드웨어 점검(POST)
    - 부팅 장치 선택
    
    **이후 디스크의 부트 영역을 읽도록 지시**
    
- **MBR (Master Boot Record)**
    - 디스크 **첫 번째 섹터**
    
    - 파티션 정보 + 부트 코드 포함
    - **Boot Loader 실행**
        
        **이후 GRUB 로드**
        
- **Boot Loader (GRUB)**
    - 부팅할 OS 선택 (부팅 가능한 OS목록이 표시됨)
    - **리눅스 커널을 메모리에 적재**
    - 커널에 부팅 옵션 전달
    - 커널에게 제어권을 넘김
    
    **이후 Kernel 커널이 실행됨**
    
- **Kernel**
    - 리눅스 핵심
    - 메모리, 프로세스, 디바이스 관리
    - 루트 파일 시스템 마운트
    
    **이후 최초 프로세스(systemd) 실행**
    

- **systemd (PID 1)**
    - 커널이 실행하는 **첫 프로세스**
    - PID = 1
    - 각종 서비스/데몬 실행 (네트워크 서비스, 로기시스템 등등)
    - 멀티유저 환경 구성
    - 부팅 단계 관리
    
    **이후 로그인 환경 준비**
    
- **Login Shell**
    - 사용자 로그인
    - 쉘 실행 (`bash` 등)
    - 시스템 사용 가능 상태

### (2) BIOS

<바이오스 개념과 특징>

- 바이오스는 컴퓨터에서 전원을 켜면 맨 처음 컴퓨터의 제어를 맡아 가장 기본적인 기능을 처리해주는 프로그램이다.
- ROM에 저장되어 있어 흔히 ROM-BIOS라고 한다.
- 메인보드에 있는 작은 메모리 칩이 따로 있는데 거기에 저장되어있다. (예전에는 ROM이었지만 최근에는 플래시 메모리 형태의 칩이 있어서 펌웨어에 버그나 보안취약점등이 있을 때수정이 가능하기도 하다)
- 펌웨어 수정이 매우 어려운 일이긴 하지만(벽돌가능성), 듀얼 BIOS, 복구 BIOS, 자동복구기능등으로 안정성이 증가함)

<바이오스의 기능>

- 부팅 전 하드웨어를 한번 초기화하여 사용을 준비하게 한다.
- PC에 장착된 기본적인 하드웨어의 상태를 확인한다.
- 소프트웨어와 하드웨어 간의 정보 전달의 매개역할을 한다.
- 하드디스크의 0번 섹터에서 MBR을 로딩한다.
    - MBR안에는 부트코드와 파티션 테이블에 대한 정볼르 가지고있다.
    - 

## [리눅스 부팅 단계별 동작]

### (1) 부트로더

<부트로더의 개념과 역할>

- 부트로더는 부트스트랩 로더의 준말로, 전원이 켜진후 운영체제를 메모리에 적재하여 실행할 수 있도록 하는 프로그램이다.
- 운영체제가 시동되기 전에 커널을 위한 환경을 성정하고 운영체제 이미지를 메모리에 복사한다음 제어권을 커널에 넘긴다.
- 임베디드 시스템에도 부트로더가 존재하는데 PC의 BIOS와 OS loader의 기능을 함께 수행함
- 부트로더는 부트 매니저라고도 하고 하드디스크의 첫번째 섹터 (MBR)에 위치한다.

<MBR과 부트 섹터 구조>

- MBR은 크기가 512바이트로, 부트로더 프로그램과 파티션 정보를 저장한다.
- 각 주 파티션에는 고유의 부트 섹터가 할당되어 부팅 프로그램을 포함한다.
- 분할된 주 파티션은 자신만의 부트 레코드를 MBR에 등록하여 실행된다.

<대표 부트로더>

- x86 아키텍쳐에서는 LILO(Linux LOader)와 GRUB(GRand Unified Bootloader)이 대표적이다.
- LILO는 리눅스 운영체제에 한정되어 사용되는 반면 GRUB는 리눅스 운영체제 외에도 다른 운영체제에서도 사용가능하다.
- 두 가지 종류의 부트로더 모두  ROM-bios에서 시스템 제어권을 가지고 하드웨어 점검과 인식을 한다 그 후 rom bios에게서 제어권을 받는다.

### (2) GRUB

<GRUB의 개요와 특징 >

- Erich stefan Boleny에 의해서 개발된 부트로더이다.
- GRUB 부트로더는 리눅스 부팅시 처음 나오는 선택화면이다.
- 리눅스 전통적인 부트로더인 LILO의 단점을 보완해서 나왔다.
- LILO에 비해 설정 및 사용이 편리하다.
- 부트 정보를 사용자가 임의로 변경할 수 있기 때문에 부팅오류시 수정하여 부팅가능하다.
- 다른 운영체제와 멀티부팅 가능하다.
- 대화형 설정이기 때문에 커널의 경로와 파일 이름만 알면 부팅할 수 있다.  (고정형이 아니라 사용자가 명령어로 부트로더와 상호작용가능)
- 메뉴 인터페이스 환경을 지원하며 대화명 모드로 부트 정보를 설정할 수 있다.
- LILO와 다르게 파일 시스템과 커널 실행 포맷을 인식할 수 있기 때문에 하드디스크 안에있는 커널의 물리적 위치를 따로 기록하지 않아도 커널 파일 경로만  알고있으면 부팅이 가능하다.

<GRUB 와 GRUB2의 비교>

| 구분 | GRUB 1 | GRUB 2 |
| --- | --- | --- |
| 설정파일 | /boot/grub/menu.lst | /boot/grub2/grub.cfg |
| 파티션 | 첫 번째 파티션은 0부터 시작 | 첫 번째 파티션은 1부터 시작 |
| root 파티션 지정 방법 | root (hd0,0) | set root=(hd0, msdos1) |
| 커널 이미지 설정 옵션 | kernel=옵션으로 커널 이미지 명시 | linux=옵션 커널 이미지 명시 |

<GRUB 1>

- grub의 환경 설정 파일은 /boot/grub/grub.conf와 링크파일 /etc/grub.conf이다.
- 실제로 해당 파일에 접근하면 아래 내용들을 볼 수 있다.
    - root(hd0,0)
        - root 파티션의 위치를 지정하며 primary master(hd0)의 첫 번쨰 파티션을 말함
    - kernel /boot/vmlinuz (커널 이미지파일)
        - 부팅하면서 메모리에 위치하는 리눅스 커널에 전달할 인수를 지정하는 옵션
        - /boot 파티션을 별도로 사용하고 있다면 커널의 위치는 kernel/boot/vm
    - initrd /boot/initrd
        - 이미지 파일의 경로를 지정하는 옵션
    - 

<GRUB 2>

- grub2의 설정 파일은 /boot/grub2/grub.cfg와 링크파일 /etc/grub2.cfg이다.
- /boot/grub2/grub.cfg는 읽기 전용이라 수정이 안됨
- /etc/default/grub와 /etc/grub.d를 통해 환경을 설정한다.
- 명령어 grub2-mkconfig를 통해 설정 내용을 적용할 수 있다.

<grub의 장치명 표기방식>

- grub에서는 롬-바이오스에서 사용하는 정보를 사용하며 IDE, SCSI장치명을 별도로 구분짓지 않는다.
- IDE와 SCSI의 구분 없이 시스템에 정착된 순서대로 hd0, hd1로 표기한다.
- 디스크 번호와 파티션은 모두 0부터 시작한다.
- (디스크장치명, 파티션명) 형식으로 표기한다.

<grub 2의 작업 모드와 명령어>

- 초기화면에서 c → 명령모드
- 초기화면에서 e → 편집모드
    
    
    | 키 | 기능 | 설명 |
    | --- | --- | --- |
    | **e** | 항목 편집 | 선택한 부팅 항목의 내용을 수정 |
    | **c** | 명령 모드 진입 | `grub>` 프롬프트로 이동 |
    | **a** | 커널 옵션 추가 | 커널 라인에 옵션 추가 |
    | **b** | 부팅 실행 | 현재 설정으로 부팅 |
    | **o** | 아래 줄 추가 | 현재 줄 아래에 새 줄 삽입 |
    | **O** | 위 줄 추가 | 현재 줄 위에 새 줄 삽입 |
    | **d** | 줄 삭제 | 선택한 줄 삭제 |
    | **ESC** | 이전 화면 복귀 | 편집 모드에서 메뉴로 돌아감 |



## [로그인 사용자 세션 관리]

### (1) 커널 초기화

<하드웨어 장치 초기화>

- 커널은 부팅 시 가장먼저 메모리, 디스크, 키보드, 마우스 등 하드웨어 장치를 검사한다.
    - 바이오스는 존재하는지 확인한다면 커널은 실제 사용준비
- 이 과정을 통해 장치 드라이버와 자원을 초기화한다.
    - 장치 드라이버 : 운영체제가 하드웨어를 제어할 수 있도록 해주는 소프트웨어

<커널 프로세스의 생성과 역할>

- 커널이 하드웨어 초기화를 끝내면 커널은 내부 작업을 수행하기 위한 커널스레드(사용자 스레드가 아님 커널내부 스레드)
- 이 스레드들은 메모리 관리등의 커널의 동작을 수행한다.
- 커널 프로세스의 개수와 종류는 리눅스의 종류와 버전에 따라 다르다.
- 커널은 메모리 관리, 스케줄링 같은 동작을 수행하기 위해 여러 개의 프로세스(커널 프로세스)들을 생성한다.
- 이 프로세스들은 일반 프로세스와 구분되도록 대괄호로 표시하며 주로 PID 번호를 낮게 배정한다.

<커널 초기화 종료와  system 서비스 실행>

- 커널 프로세스가 생성되면 커널이 수행할 초기화 작업이 끝난다.
- 커널은 초기화 작업과 커널 스레드 생성을 완료한 후 최초의 사용자 공간 프로세스인 systemd를 실행한다.(PID=1)

### (2) Systemd

<init에서 systemd로의 전환과 런레벨>

- systemd의 개념
    - systemd 서비스는 기존의 init 스크립트를 대체한 것으로 다양한 서비스를 동작시킨다.
    - systemd는 다양한 서비스 데몬을 시작하고 프로세스를 유지하며 시스템 상태를 관리한다.
    - 각 서비스를 시작하는 과정은 화면에 메시지로 출력된다.

- init에서 systemd로의 전환과 런레벨
    - centOS는 버전 7부터 init대신에 systemd를 사용하기 시작했고, pid=1이다.
    - 이전 버전과의 호환성 떄문에 inittab파일을 유지하긴하지만 systemd를 사용한다.
    - init은 시스템의 상태를 7개로 구분하고 각 단계에 따라 스크립트를 실행하는데 이 단계들을 런 레벨이라고한다.
    
    | 런레벨 | 의미 | 설명 |
    | --- | --- | --- |
    | **0** | 시스템 종료 (halt) | 시스템 완전 종료 |
    | **1** | 단일 사용자 모드 (single mode) | 관리자 점검/복구 모드, 네트워크 X |
    | **2** | 멀티유저 모드 | 네트워크 미사용 (배포판마다 다름) |
    | **3** | 멀티유저 모드 (텍스트) | 네트워크 포함, CLI 환경 |
    | **4** | 사용자 정의 | 일반적으로 사용 안 함 |
    | **5** | 멀티유저 + GUI | 그래픽 로그인 화면 |
    | **6** | 재부팅 (reboot) | 시스템 재시작 |
    - 현재 시행되는 런레벨을 확인하는 명령어는 “runlevel”이다.


<systemd의 주요 특징>

- centOs는 버전 7부터 대부분의 서비스가 systemd 기반으로 바뀌었다.
- systemd의 장점은 아래와 같다.
    - 소켓 기반이기 때문에 inetd와 호환성을 유지 → 요청이 들어올 때만 서비스 실행
    - 셸과 독립적으로 부팅이 가능하다. → 셸에 의존하지 않기때문에 더 빠르고 안정적
    - 마운트와 fsck제어가 가능하다.
    - 시스템 상태에 대한 스냅샷을 유지 → 원인파악과 복구 쉬움
    - SELinux와 통합이 가능함 → 보안 정책 시스템
    - 서비스에 시그널을 전달할 수 있다 → start, stop, restart, reload등의 명령어로 서비스에 정확한 시그널 전달 (강제명령어보다 안전, )
    - 셨다운 전에 사용자 세션의 안전한 종료가 가능하다 .→ 데이터 손실방지, 깔끔

<systemd의 유닛과 명령어 체계>

- systemd는 시스템을 관리하는데 “unit”을 사용한다.
    - 서비스, 마운트, 소켓,타이머,  장치등등 전부를 unit파일로 관리함.
- 관리 대상 이름을 “서비스명,유닛종류” 형식으로 관리한다
    - nginx.service
    - sshd.service
    - home.mount
    - cron.timer등등
- 각 유닛은 같은 이름과 종류로 구성된 설정 파일과 동일한 이름을 사용한다. → 유닛이름의 결정은 설정파일의 이름을 따오면 되는 것.
- 유닛 종류와 기능은 다음과 같다.
    
    
    | 유닛 종류 | 기능 | 예시 |
    | --- | --- | --- |
    | **service** | 시스템 서비스(데몬)를 시작/종료/재시작/리로드 | `atd.service` |
    | **target** | 여러 유닛을 그룹화하여 특정 상태 구성 | `basic.target` |
    | **automount** | 자동 마운트 포인트 관리 | `proc-sys-fs-binfmt_misc.automount` |
    | **device** | 리눅스 장치 트리에 있는 장치 관리 | `sys-module-fuse.device` |
    | **mount** | 파일 시스템의 마운트 포인트 관리 | `boot.mount` |
    | **path** | 특정 파일/디렉터리 경로 변화 감지 | `cups.path` |
    | **scope** | 외부에서 생성된 프로세스 그룹 관리 | `init.scope` |
    | **slice** | 시스템 프로세스를 계층적으로 관리 | `system-getty.slice` |
    | **socket** | 소켓 기반 서비스 관리 (AF_INET, AF_UNIX 등) | `dbus.socket` |
    | **swap** | 스왑 장치 관리 | `dev-mapper-fedora.swap` |
    | **timer** | 예약 실행 기능 관리 (cron 대체 가능) | `dnf-makecache.timer` |


  - systemd 기반 서비스를 제어하는 명령어는 systemctl이다.
    
    
    | 명령어 | 설명 |
    | --- | --- |
    | `systemctl` | 현재 동작 중인 유닛 출력 |
    | `systemctl -a` | 전체 유닛 출력 |
    | `systemctl status 유닛명` | 유닛 상태 확인 |
    | `systemctl stop 유닛명` | 유닛 정지 |
    | `systemctl start 유닛명` | 유닛 시작 |
    | `systemctl restart 유닛명` | 유닛 재시작 |

- 디렉토리 /usr/lib/system/system에 런레벨 관련 파일들이 있다
- 각 레벨 관련 파일들은 “runlevel숫자.target” 심볼릭 링크 형태이다.
- 런레벨과 target유닛과의 관계는 다음과 같다.
    
    
    | 런레벨 | target 파일(심볼릭 링크) | target 원본 파일 |
    | --- | --- | --- |
    | 0 | runlevel0.target | poweroff.target |
    | 1 | runlevel1.target | rescue.target |
    | 2 | runlevel2.target | multi-user.target |
    | 3 | runlevel3.target | multi-user.target |
    | 4 | runlevel4.target | multi-user.target |
    | 5 | runlevel5.target | graphical.target |
    | 6 | runlevel6.target | reboot.target |

  
- target과 런레벨 관련 명령어들은 다음과 같다.
    
    
    | 명령어 | 설명 | 예제 |
    | --- | --- | --- |
    | `systemctl get-default` | 현재 기본 타겟 확인 | `systemctl get-default` |
    | `systemctl set-default 타겟명.target` | 기본 타겟(런레벨) 지정 | `systemctl set-default rescue.targetsystemctl set-default multi-user.targetsystemctl set-default graphical.target` |
    | `systemctl isolate 타겟명` | 현재 타겟(런레벨) 즉시 변경 | `systemctl isolate rescuesystemctl isolate graphical` |
    | `systemctl isolate runlevelN` | 런레벨 방식으로 변경 | `systemctl isolate runlevel1systemctl isolate runlevel5` |
    | `init N` | 런레벨 변경 (호환용) | `init 1` |
    | `telinit N` | 런레벨 변경 (호환용) | `init S` |

- init은 프로세스이기도 하지만 런레벨 변경 시에도 사용한 명령어이다.

### (3) 로그인과 로그아웃

<로그인>

- 리눅스는 X윈도우 상에서 로그인/로그아웃과 콘솔상에서의 로그인/로그아웃이 있다.
    - X윈도우 : 리눅스에서 그래픽 화면을 출력해주는 그래픽 시스템이다.
- 로그인 과정은 다음과 같다.
    - 입력한 패스워드와 파일 /etc/passwd 필드를 비교한다. → 현재는 입력한 비밀번호를 암호화 하여 /etc/shadow의 해시값과 비교
    - 셸 설정 파일을 실행한다. 셸 설정 파일은 다음과 같은 일을 수행한다.
        - 검색 경로 설정
        - 터미널 종류및 환경설정
        - 환경변수 설정
        - 로그인 시 실행 명령어 실행
        - 로그인 메시지 출력
    - 그 이후 로그인 셸을 실행한다.
        - 로그인 셸은 파일 /etc/passwd의 마지막 필드에 정의되어 있다.
        - 로그인 셸에 따라 프롬프트가 다르다.
            
            
            | 쉘 종류 | 저장 위치 | 기본 프롬프트 |
            | --- | --- | --- |
            | **sh** | `/bin/sh` | `$` |
            | **csh** | `/bin/csh` | `%` |
            | **ksh** | `/bin/ksh` | `$` |
            | **bash** | `/bin/bash` | `$` |
            
            ![image.png](attachment:b65dab73-8a9c-4f86-b29d-45a7d0b5b539:image.png)
            

<로그아웃>

- 로그아웃은 logout, exit또는 컨트롤+D를 사용한다.
- 관리자는 일정 시간 작업을 수행하지 않는 모든 사용자들을 강제로 로그아웃시킬 수 있다.
- 강제 로그아웃은 /etc/profile에 TMOUT 변수에 값을 지정하여 해당 작업을 수행한다.
