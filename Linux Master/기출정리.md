# PATH

- PATH : **쉘이 명령어를 찾을 때 참고하는 “목록”**
- PATH는 단일 문자열이지만 :을 기준으로 실행파일이 있는 디렉토리들을 저장한다.
- PATH에 경로들을 저장하면
    1. PATH에 등록된 디렉터리들을
    2. **왼쪽부터 순서대로 탐색**
    3. 해당 이름의 실행 파일이 있으면 실행
    
    4. 동일한 이름의 명령어가 있으면 먼저 발견된 것 실행
    
- **PATH에 추가한 디렉터리에 있는 모든 실행 파일이 명령어로 실행 가능해진다.**

# LILO 부트로더

- BIOS → MBR → LILO 1차 부트로더 → LILO 2차 부트로더 → 커널 load

## 디스크 지오메트리

- 디스크를 몇 번째 실린더, 몇 번째 헤드, 몇 번째 섹터로 나눠서 주소를 매기는 방식 (CHS)
- BIOS는 CHS방식으로 디스크를 읽게 된다.
- 하지만 리눅스는 LBA (logical block Addressing)을 사용한다.
- LILO는 바이오스의 도움을 받아서 부팅을 하기 때문에 바이오스가 디스크를 읽는 방식인 CHS 기준으로 map파일을 만들게 된다.
- 리눅스는 LBA을 기본적으로 사용하기 때문에 이를 기반으로 CHS로 계산해서 변환하는데 이 변환결과가 미묘하게 다르면
- /boot/map 에 기록된 디스크주소가 서로 다를 수 있다.
- 그러면 부트로더가 잘못된 디스크 주소를 참조하게 된다.
- 그러면 LI에서 멈출 수 있다.

- 부팅할 때 결국 커널을 메모리에 올려야 부팅이 성공되는 것
- 커널은 디스크 안에 파일 형태로 존재한다.
- 하지만 LILO부트로더는 파일시스템을 이해하지 못하기 때문에 파일 이름으로 커널파일을 찾는 등의 행위는 하지 못하기 때문에
- /boot/map경로에 커널파일의 물리적인 위치를 기록해두어야한다.
- 그런데 위에서 말한 주소계산방식의 차이로 인한 미묘한 차이로 map에 기록된 커널주소가 다르면 부팅오류가 발생할 수 있다.

→ 하지만 LILO가 아니라 GRUB을 사용하면 LBA를 사용하고, 파일 시스템을 이해할 수 있기 때문에 GRUB에서는 거의 발생하지 않는 문제이다. 

## map파일(/boot/map)

- 커널과 2차 부트로더가 디스크의 어떤 위치에 있는지 적어둔 파일
- LILO는 파일 시스템을 이해하지 못하기 때문에 물리적인 디스크 위치를 기록해두어야한다.
- 그게 /boot/map이다.

## Map Installer (LILO 명령)

- /boot/map파일을 새로 만들어주는 설치 프로그램
- 커널 위치 게산
- 디스크 주소 계산
- /boot/map갱신

## 디스크립터 테이블

- 부트 로더가 다음 단계로 넘어가기 위해 참조하는 테이블


# 절대경로와 상대경로

- /로 시작하면 절대경로, /가 없으면 상대경로로 인식된다.
- 예를들어 현재 위치를 /home/user1이라고 하자.
- cd .. → 상대경로로 현재 디렉토리의 부모 디렉터리가 된다. → /home
- cd /home → 절대 경로 → /home
- cd ./.. → 상대경로의 → 현재 디렉토리의 부모 디렉토리 → /home
- cd home → 상대경로 → 현재 디렉토리 및에 있는 home이라는 디렉토리 → /home/user1/home

# users명령어

- 현재 시스템에 로그인되어 있는 사용자 계정들을 출력하는 명령어
- who는 여기에다가 터미널, 로그인시각까지 보여줌

# 리눅스의 시스템 파티션 분할

- 전통적으로 루트(/)와 swap 이렇게 최소 2개는 분리하는 것이 기본이다.
- 만약 서버로 사용하는 경우에는 4개 이상의 파티션 분할이 필요
    - /
    - swap
    - /home
    - /tmp
    - /usr
    - /var : 로그, 메일, DB
    - /→ /var → /tmp → /home → /usr → /etc
    (왼쪽일수록 분리 우선순위 높음)
- /home, /var, /usr등의 파티션은 분할하도록 권장
    - /home : 사용자 데이터 분리
    - /tmp : 임시파일, 프로세스/공격대상
    - /usr : 프로그램, 라이브러리, 시스템 프로그램 안정화
    - /var : 로그, 메일, DB →  / 를 보호
- 전통적인 리눅스에서는 처음 설치시 분할한 파티션은 고정하고 자유롭게 변경하지 않는다. LVM을 사용한다면 변경할 수는 있다.

# 패스워드 설정과정

- passwd 사용자명 입력후 엔터
- New password입력시 보안목적으로 아무것도 입력한 게 보이지는 않지만 정상적으로 입력받음.
- 다시 입력하라(retype)는 프롬프트가 나오면 다시 입력
- 설정된 암호는 원할 때 언제든 변경가능하다.

# 명령어

- Rescue installed system
    - 이미 설치된 리눅스를 최소 환경으로 부팅해서 파일시스템, 부트로더, 설정 파일등을 점검, 복구하는 모드
    
    → 시스템 정상 부팅 안 될때 사용.
    
- Install or upgrade an existing system
    - 새로 설치하거나 업그레이드할 때 사용
- Install system with basic video driver
    - 그래픽 드라이버 충돌 시 설치용
- Boot from local drive

# 배포판 설치시 선택할 수 있는 영역들

- 워크스테이션 : GUI 있는 개인/개발자용
- 서버

- install/Upgrade/Rescue
    - install : 새로 설치
    - upgrade : 기존 시스템 유지하면서 버전만 업그레이드
    - Rescue : 고장난 시스템 복구
 
# shutdown 명령어

- -c : 예약된 shutdown 명령을 취소
- -h : 전원종료
- -f : fast boot, 재부팅시 fsck건너뜀
- -r : 재부팅

# 사용자 정보 변경

- ihduser라는 사용자의 그룹을 IHD라는 그룹으로 변경시키고 싶을 때.
- usermod라는 명령어를 사용한다.
- user modify의 약자인 것으로 추정. (사용자 정보를 수정하는 명령)
- 이외에도 사용자, 그룹관련 명령어들이 있음
    - useradd : 사용자 생성
    - userdel : 사용자 제거
    - groupadd : 그룹 생성
    - groupdel : 그룹 제거
    - groupmod : 그룹 수정

```bash
# 1) -g : 주 그룹(primary group) 변경
usermod -g IHD ihduser

# 2) -G : 보조 그룹(supplementary group) 설정 (기존 보조 그룹 덮어씀)
usermod -G dev,admin ihduser

# 3) -aG : 보조 그룹 추가 (기존 보조 그룹 유지)
usermod -aG docker ihduser

# 4) -d : 홈 디렉토리 변경
usermod -d /home/ihduser_new ihduser

# 5) -s : 로그인 쉘 변경
usermod -s /bin/bash ihduser

# 6) -l : 사용자 이름 변경
usermod -l newuser ihduser

```


# 특수 권한 비트 정리

(setuid / setgid / sticky bit)

## 1️⃣ setuid (Set User ID)

### 개념

- **실행 파일에만 적용**
- 실행 시 **파일 소유자의 권한**으로 프로세스가 실행됨

### 왜 필요한가

- 일반 사용자가 **root 권한이 필요한 작업 일부만** 수행하게 하기 위해

### 확인 포인트

- 소유자 실행 권한 위치에 `s` 또는 `S`

### 설정 예시

```bash
chmod u+s file
chmod 4755 file

```

### 대표 예

- `/usr/bin/passwd`

## 2️⃣ setgid (Set Group ID)

### 개념

- **파일과 디렉토리 모두 적용 가능**

### 파일에 적용 시

- 실행 시 **파일 소유 그룹 권한**으로 실행

### 디렉토리에 적용 시

- 하위에 생성되는 파일/디렉토리가
    
    **부모 디렉토리의 그룹을 자동 상속**
    

### 확인 포인트

- 그룹 실행 권한 위치에 `s` 또는 `S`

### 설정 예시

```bash
chmod g+s file_or_dir
chmod 2755 file_or_dir

```

---

## 3️⃣ Sticky Bit

### 개념

- **디렉토리에만 적용**
- 파일 소유자, 디렉토리 소유자, root만 삭제 가능

### 왜 필요한가

- 여러 사용자가 쓰는 **공용 디렉토리 보호**

### 확인 포인트

- other 실행 권한 위치에 `t` 또는 `T`

### 설정 예시

```bash
chmod +t dir
chmod 1777 dir

```

### 대표 예

- `/tmp`

---

## 4️⃣ 세 가지 한 눈에 비교 (시험용 핵심 표)

| 구분 | setuid | setgid | sticky bit |
| --- | --- | --- | --- |
| 적용 대상 | 파일 | 파일 / 디렉토리 | 디렉토리 |
| 실행 시 효과 | 소유자 권한 | 소유 그룹 권한 | 실행과 무관 |
| 디렉토리 효과 | ❌ 없음 | 그룹 상속 | 삭제 제한 |
| 표시 위치 | user x 자리 | group x 자리 | other x 자리 |
| 숫자 값 | 4 | 2 | 1 |
| 대표 예 | passwd | 공유 프로젝트 폴더 | /tmp |

---

## 5️⃣ s / S / t / T 차이 (함정 정리)
| 표시 | 의미 |
| --- | --- |
| s | 실행 권한 O + 특수 권한 |
| S | 실행 권한 X + 특수 권한 |
| t | 실행 권한 O + sticky |
| T | 실행 권한 X + sticky |


## reboot 명령어

## reboot란?

**리눅스 시스템을 정상 종료 절차를 거친 뒤 재부팅**하는 명령어다.

전원을 그냥 끊는 게 아니라 **파일 시스템과 프로세스를 안전하게 정리**한 후 다시 부팅한다.

### reboot 실행 시 내부 동작 흐름

1. **로그인된 사용자 및 프로세스 종료**
2. **실행 중인 서비스 데몬 종료**
3. **파일 시스템 sync**
4. **파일 시스템 unmount**
5. **시스템 종료 절차 수행**
6. **재부팅 수행**

### 관련 명령어 비교

| 명령어 | 의미 |
| --- | --- |
| reboot | 정상 종료 후 재부팅 |
| shutdown -r now | 즉시 재부팅 |
| shutdown -h now | 종료 |
| halt | CPU 정지 |
| poweroff | 전원 종료 |

## SWAP 정리

### SWAP이란?

**SWAP(스왑)** 은

**물리 메모리(RAM)가 부족할 때 디스크 일부를 가상 메모리처럼 사용하는 공간**이다.

- RAM 부족 → 프로세스 일부를 디스크로 내보냄
- RAM 여유 → 다시 불러옴

즉, **메모리 부족을 보완하기 위한 임시 저장 공간**

### SWAP 동작 원리

- RAM 사용량 증가
- 커널이 **사용 빈도 낮은 메모리 페이지 선택**
- 해당 페이지를 **SWAP 영역으로 이동**
- RAM 공간 확보
- 필요 시 다시 RAM으로 로드

👉 이 과정을 **paging / swapping** 이라고 함

⚠️ 디스크 기반이라 **RAM보다 훨씬 느림**

### SWAP의 목적

- 메모리 부족으로 인한 **프로그램 강제 종료 방지**
- 시스템 안정성 확보
- 일시적인 메모리 확장 효과

❌ RAM을 대체하는 개념 아님

❌ 성능 향상 목적 아님

---

### SWAP의 종류

**Swap Partition**

- 디스크 파티션을 SWAP으로 지정
- 설치 시 설정하는 경우 많음
- 성능·안정성 좋음

**Swap File**

- 일반 파일을 SWAP으로 사용
- 실행 중 생성/삭제 가능
- 유연하지만 파티션보다 약간 느림
