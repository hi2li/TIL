# PATH

- PATH : **쉘이 명령어를 찾을 때 참고하는 “목록”**
- PATH는 단일 문자열이지만 :을 기준으로 실행파일이 있는 디렉토리들을 저장한다.
- PATH에 경로들을 저장하면
    1. PATH에 등록된 디렉터리들을
    2. **왼쪽부터 순서대로 탐색**
    3. 해당 이름의 실행 파일이 있으면 실행
    
    4. 동일한 이름의 명령어가 있으면 먼저 발견된 것 실행
    
- **PATH에 추가한 디렉터리에 있는 모든 실행 파일이 명령어로 실행 가능해진다.**

# LILO 부트로더

- BIOS → MBR → LILO 1차 부트로더 → LILO 2차 부트로더 → 커널 load

## 디스크 지오메트리

- 디스크를 몇 번째 실린더, 몇 번째 헤드, 몇 번째 섹터로 나눠서 주소를 매기는 방식 (CHS)
- BIOS는 CHS방식으로 디스크를 읽게 된다.
- 하지만 리눅스는 LBA (logical block Addressing)을 사용한다.
- LILO는 바이오스의 도움을 받아서 부팅을 하기 때문에 바이오스가 디스크를 읽는 방식인 CHS 기준으로 map파일을 만들게 된다.
- 리눅스는 LBA을 기본적으로 사용하기 때문에 이를 기반으로 CHS로 계산해서 변환하는데 이 변환결과가 미묘하게 다르면
- /boot/map 에 기록된 디스크주소가 서로 다를 수 있다.
- 그러면 부트로더가 잘못된 디스크 주소를 참조하게 된다.
- 그러면 LI에서 멈출 수 있다.

- 부팅할 때 결국 커널을 메모리에 올려야 부팅이 성공되는 것
- 커널은 디스크 안에 파일 형태로 존재한다.
- 하지만 LILO부트로더는 파일시스템을 이해하지 못하기 때문에 파일 이름으로 커널파일을 찾는 등의 행위는 하지 못하기 때문에
- /boot/map경로에 커널파일의 물리적인 위치를 기록해두어야한다.
- 그런데 위에서 말한 주소계산방식의 차이로 인한 미묘한 차이로 map에 기록된 커널주소가 다르면 부팅오류가 발생할 수 있다.

→ 하지만 LILO가 아니라 GRUB을 사용하면 LBA를 사용하고, 파일 시스템을 이해할 수 있기 때문에 GRUB에서는 거의 발생하지 않는 문제이다. 

## map파일(/boot/map)

- 커널과 2차 부트로더가 디스크의 어떤 위치에 있는지 적어둔 파일
- LILO는 파일 시스템을 이해하지 못하기 때문에 물리적인 디스크 위치를 기록해두어야한다.
- 그게 /boot/map이다.

## Map Installer (LILO 명령)

- /boot/map파일을 새로 만들어주는 설치 프로그램
- 커널 위치 게산
- 디스크 주소 계산
- /boot/map갱신

## 디스크립터 테이블

- 부트 로더가 다음 단계로 넘어가기 위해 참조하는 테이블


# 절대경로와 상대경로

- /로 시작하면 절대경로, /가 없으면 상대경로로 인식된다.
- 예를들어 현재 위치를 /home/user1이라고 하자.
- cd .. → 상대경로로 현재 디렉토리의 부모 디렉터리가 된다. → /home
- cd /home → 절대 경로 → /home
- cd ./.. → 상대경로의 → 현재 디렉토리의 부모 디렉토리 → /home
- cd home → 상대경로 → 현재 디렉토리 및에 있는 home이라는 디렉토리 → /home/user1/home

# users명령어

- 현재 시스템에 로그인되어 있는 사용자 계정들을 출력하는 명령어
- who는 여기에다가 터미널, 로그인시각까지 보여줌

# 리눅스의 시스템 파티션 분할

- 전통적으로 루트(/)와 swap 이렇게 최소 2개는 분리하는 것이 기본이다.
- 만약 서버로 사용하는 경우에는 4개 이상의 파티션 분할이 필요
    - /
    - swap
    - /home
    - /tmp
    - /usr
    - /var : 로그, 메일, DB
    - /→ /var → /tmp → /home → /usr → /etc
    (왼쪽일수록 분리 우선순위 높음)
- /home, /var, /usr등의 파티션은 분할하도록 권장
    - /home : 사용자 데이터 분리
    - /tmp : 임시파일, 프로세스/공격대상
    - /usr : 프로그램, 라이브러리, 시스템 프로그램 안정화
    - /var : 로그, 메일, DB →  / 를 보호
- 전통적인 리눅스에서는 처음 설치시 분할한 파티션은 고정하고 자유롭게 변경하지 않는다. LVM을 사용한다면 변경할 수는 있다.

# 패스워드 설정과정

- passwd 사용자명 입력후 엔터
- New password입력시 보안목적으로 아무것도 입력한 게 보이지는 않지만 정상적으로 입력받음.
- 다시 입력하라(retype)는 프롬프트가 나오면 다시 입력
- 설정된 암호는 원할 때 언제든 변경가능하다.

# 명령어

- Rescue installed system
    - 이미 설치된 리눅스를 최소 환경으로 부팅해서 파일시스템, 부트로더, 설정 파일등을 점검, 복구하는 모드
    
    → 시스템 정상 부팅 안 될때 사용.
    
- Install or upgrade an existing system
    - 새로 설치하거나 업그레이드할 때 사용
- Install system with basic video driver
    - 그래픽 드라이버 충돌 시 설치용
- Boot from local drive

# 배포판 설치시 선택할 수 있는 영역들

- 워크스테이션 : GUI 있는 개인/개발자용
- 서버

- install/Upgrade/Rescue
    - install : 새로 설치
    - upgrade : 기존 시스템 유지하면서 버전만 업그레이드
    - Rescue : 고장난 시스템 복구
 
# shutdown 명령어

- -c : 예약된 shutdown 명령을 취소
- -h : 전원종료
- -f : fast boot, 재부팅시 fsck건너뜀
- -r : 재부팅

# 사용자 정보 변경

- ihduser라는 사용자의 그룹을 IHD라는 그룹으로 변경시키고 싶을 때.
- usermod라는 명령어를 사용한다.
- user modify의 약자인 것으로 추정. (사용자 정보를 수정하는 명령)
- 이외에도 사용자, 그룹관련 명령어들이 있음
    - useradd : 사용자 생성
    - userdel : 사용자 제거
    - groupadd : 그룹 생성
    - groupdel : 그룹 제거
    - groupmod : 그룹 수정

```bash
# 1) -g : 주 그룹(primary group) 변경
usermod -g IHD ihduser

# 2) -G : 보조 그룹(supplementary group) 설정 (기존 보조 그룹 덮어씀)
usermod -G dev,admin ihduser

# 3) -aG : 보조 그룹 추가 (기존 보조 그룹 유지)
usermod -aG docker ihduser

# 4) -d : 홈 디렉토리 변경
usermod -d /home/ihduser_new ihduser

# 5) -s : 로그인 쉘 변경
usermod -s /bin/bash ihduser

# 6) -l : 사용자 이름 변경
usermod -l newuser ihduser

```
